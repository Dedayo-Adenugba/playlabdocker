rocket: DevOps Intern Stage 2 Task - Blue/Green with Nginx Upstreams (Auto-Failover + Manual Toggle) Hey Cool Keeds! :wave: :dart: Overview Your task is to deploy a Blue/Green Nodejs service behind Nginx using pre-built container images (no application code changes, no image rebuilds). You will configure routing, health-based failover, and automated verification via CI. :hammer_and_spanner: Task Breakdown What you’re deploying Two identical Nodejs services shipped as ready-to-run images:  Blue (active) and Green (backup) instances  Expose these endpoints (already implemented in the image):  GET /version → returns JSON and headers  POST /chaos/start → simulates downtime (500s or timeout)  POST /chaos/stop → ends simulated downtime  GET /healthz → process liveness You must place Nginx in front of them and ensure:  Normal state: all traffic goes to Blue  On Blue’s failure: Nginx automatically switches to Green with zero failed client requests  If Blue fails a request (timeout or 5xx), Nginx retries to Green within the same client request so the client still receives 200.  Blue is active by default, Green is backup.  Do not strip upstream headers; forward app headers to clients. Failover mechanics (conceptual requirements):  Primary/backup upstreams (use the backup role).  Tight timeouts so failures are detected quickly.  Retry policy that considers error, timeout, and http_5xx retriable.  Mark primary with a low max_fails + short fail_timeout. Headers On every successful response, the apps include:  X-App-Pool: blue|green (literal pool identity)  X-Release-Id: <string> (a release identifier) You must ensure Nginx forwards these headers unchanged. Environment, ports, and parameterization Run everything with Docker Compose:  Nginx public entrypoint: http://localhost:8080  Blue direct port (grader triggers chaos here): http://localhost:8081  Green direct port: http://localhost:8082 Your Compose file must be fully parameterized via a .env:  BLUE_IMAGE — image reference for Blue - Image link  GREEN_IMAGE — image reference for Green - Image link  ACTIVE_POOL — blue or green (controls Nginx template)  RELEASE_ID_BLUE, RELEASE_ID_GREEN — passed into the app containers so they return these in X-Release-Id  (Optional) PORT -To determine the port the application should run on The CI/grader will set these variables. Required behavior  Baseline (Blue active)  GET <http://localhost:8080/version> → 200, headers show:  X-App-Pool: blue ($APP_POOL)  X-Release-Id: $RELEASE_ID   consecutive requests: all 200, all indicate blue.  Induce downtime on the active app (Blue)   POST <http://localhost:8081/chaos/start?mode=error> (or a timeout mode)  Immediate switch to Green  Next GET <http://localhost:8080/version> → 200 with headers:  X-App-Pool: green ($APP_POOL)  X-Release-Id: $RELEASE_ID 4. Stability under failure  Requests to http://localhost:8080/version within ~10s:  0 non-200s allowed  ≥95% responses must be from green (with recommended timeouts this should be ~100%) Fail conditions  Any non-200 after chaos during the request loop.  Headers don’t match the expected pool/release before/after failover.  No switch observed after chaos. Constraints (do’s & don’ts)  :white_tick: Use Docker Compose to orchestrate nginx, app_blue, app_green.  :white_tick: Template the Nginx config from ACTIVE_POOL (e.g., envsubst) and support nginx -s reload.  :white_tick: Expose Blue/Green on 8081/8082 so the grader can call /chaos/* directly.  :x: No Kubernetes, no swarm, no service meshes.  :x: No building or modifying app images; no Docker build in CI.  :x: Do not bypass Nginx for the main service endpoint.  :x: A request should not be more than 10 seconds Part B: DevOps Research Task – Infrastructure Setup & CLI Flow for Backend.im :dart: Task Objective: Research and propose how to set up the infrastructure and workflow that enables developers to push and deploy backend code directly to Backend.im via the Claude Code CLI and other AI tools, using mostly open-source tools and requiring minimal configuration. The sample of what this research is to accomplish, is demonstrated in this video. :hammer_and_spanner: Core Problem to Solve: Design a simple, cost-efficient setup where a developer can go from having code locally to having it deployed and live on Backend.im—entirely through the Claude Code CLI and other AI tools—without relying on complex manual setup or proprietary services. :compass: Guidelines:  Prioritize open-source, lightweight, and cost-free tooling where possible.  The goal is not to implement but to show how you would structure and reason through it.  Think of this like designing the “plumbing” that makes a one-command deployment possible. :scroll: Deliverable:  A short report or presentation covering:  Proposed architecture and reasoning  Tools or frameworks you’d use (and why)  Local setup flow  High-level deployment sequence diagram  Where minimal custom code would be required :package: Submission Requirements For Part A of the Task:  Ensure your repo contains your docker-compose.yml, .env.example, and a README.md explaining how to run it.  Your template nginx config should also be in your repo.  (optional) In your repo, add a DECISION.md file explaining your thought process or anything you would like us to know about your implementation. This has no negative implication on your final score. Walk me through the breakdown of this task like a layman












---------------------------------------------------------------------------------------------------------------
Develop a robust, production-grade Bash script that automates the setup, deployment, and configuration of a Dockerized application on a remote Linux server.
:hammer_and_spanner: Task Breakdown
Your script (deploy.sh) should be a single, executable Bash file that performs all actions in sequence, with proper error handling, validation, and logging throughout.
1. Collect Parameters from User Input
Prompt for and validate:
Git Repository URL
Personal Access Token (PAT)
Branch name (optional; defaults to main)
Remote server SSH details:
Username
Server IP address
SSH key path
Application port (internal container port)
2. Clone the Repository
Authenticate and clone the repo using the PAT.
If it already exists, pull the latest changes instead.
Switch to the specified branch.
3. Navigate into the Cloned Directory
Automatically cd into the cloned project folder.
Verify that a Dockerfile or docker-compose.yml exists.
Log success or failure.
4. SSH into the Remote Server
Establish SSH connection with provided credentials.
Perform connectivity checks (ping or SSH dry-run).
Execute remaining commands remotely (ssh user@ip "commands...").
5. Prepare the Remote Environment
On the remote host:
Update system packages.
Install Docker, Docker Compose, and Nginx (if missing).
Add user to Docker group (if needed).
Enable and start services.
Confirm installation versions.
6. Deploy the Dockerized Application
Transfer project files (via scp or rsync).
Navigate to project directory.
Build and run containers (docker build + docker run or docker-compose up -d).
Validate container health and logs.
Confirm app accessibility on the specified port.
7. Configure Nginx as a Reverse Proxy
Dynamically create or overwrite Nginx config.
Forward HTTP (port 80) traffic to container’s internal port.
Ensure SSL readiness (optional self-signed cert or Certbot placeholder).
Test config and reload Nginx.
8. Validate Deployment
Confirm that:
Docker service is running.
The target container is active and healthy.
Nginx is proxying correctly.
Test endpoint using curl or wget locally and remotely.
9. Implement Logging and Error Handling
Log all actions (success/failure) to a timestamped log file (e.g., deploy_YYYYMMDD.log).
Include trap functions for unexpected errors.
Use meaningful exit codes per stage.
10. Ensure Idempotency and Cleanup
Script should safely re-run without breaking existing setups.
Gracefully stop/remove old containers before redeployment.
Prevent duplicate Docker networks or Nginx configs.
(Optional) Include a --cleanup flag to remove all deployed resources.
:package: Submission Guidelines
Push your Bash script (deploy.sh) and a clear README.md to your GitHub repo.
Script must be POSIX-compliant and executable (chmod +x deploy.sh).
Do not use configuration management tools like Ansible or Terraform.
:drawing_pin: Submission Process
Verify your server works (test from multiple networks if possible)
Go to the #track-devops and stage-1-devops channel in Slack
Run the command:  “/stage-one-devops”
Submit:
Your fullname and
Your github repo url  in this format https://github.com/username/repo
 5.  Please check Thanos bot to see the error message or success message after each attempt.
:alarm_clock: Deadline & Attempts
Deadline: 11:59 PM GMT, 22nd October 2025
Attempts Allowed: 5











----------------------------------------------------

ssh -i ~/.ssh/id_rsa ubuntu@<your-server-ip>

-------------------------------------------------

sudo apt update
sudo apt install -y git openssh-client rsync curl
--------------------------------------------------
mkdir ~/deploy-work && cd ~/deploy-work
-----------------------------------------------
#!/usr/bin/env bash
# ==============================================================================
# deploy.sh  |  Automated Docker Deployment Script
# ==============================================================================
# Author: <Your Name>
# Description:
#   A single, self-contained Bash script that:
#     1. Collects parameters (repo, SSH, etc.)
#     2. Clones or updates a Git repo using a PAT
#     3. Validates Dockerfile/docker-compose.yml
#     4. Connects to a remote server via SSH
#     5. Prepares remote environment (Docker, Nginx)
#     6. Transfers files and runs containers
#     7. Configures Nginx reverse proxy
#     8. Validates deployment and logs all actions
#     9. Supports --cleanup flag for full removal
#
# Usage:
#   chmod +x deploy.sh
#   ./deploy.sh          → normal deployment
#   ./deploy.sh --cleanup → remove deployed resources
# ==============================================================================

set -o errexit
set -o nounset
set -o pipefail

# ------------------------------------------------------------------------------
# Logging setup
# ------------------------------------------------------------------------------
LOG_DIR="./logs"
mkdir -p "$LOG_DIR"
LOG_FILE="${LOG_DIR}/deploy_$(date +%Y%m%d_%H%M%S).log"
exec > >(tee -a "$LOG_FILE") 2>&1

log() { echo "$(date --iso-8601=seconds) [INFO]  $*"; }
err() { echo "$(date --iso-8601=seconds) [ERROR] $*" >&2; }
die() { err "$1"; exit "${2:-1}"; }

trap 'err "Unexpected error occurred at line $LINENO"; exit 1' ERR

# ------------------------------------------------------------------------------
# Section 1 — Collect User Input
# ------------------------------------------------------------------------------
if [[ "${1:-}" == "--cleanup" ]]; then
  CLEANUP_MODE=true
else
  CLEANUP_MODE=false
fi

log "=== Collecting user inputs ==="
read -rp "Git repository URL (HTTPS): " GIT_REPO
printf "Personal Access Token (hidden): "
stty -echo; read -r GIT_PAT; stty echo; echo
read -rp "Branch (default 'main'): " BRANCH; BRANCH=${BRANCH:-main}
read -rp "Remote SSH username: " REMOTE_USER
read -rp "Remote server IP address: " REMOTE_HOST
read -rp "SSH key path (e.g. ~/.ssh/id_rsa): " SSH_KEY
read -rp "Application internal port (container): " APP_PORT

[[ -n "$GIT_REPO" ]] || die "Repository URL is required."
[[ -f "$SSH_KEY" ]] || die "SSH key not found at $SSH_KEY."

REPO_NAME="$(basename -s .git "$GIT_REPO")"
LOCAL_DIR="./${REPO_NAME}"
AUTH_URL="${GIT_REPO/https:\/\//https://${GIT_PAT}@}"

log "Collected inputs:
  Repo: $GIT_REPO
  Branch: $BRANCH
  Remote: $REMOTE_USER@$REMOTE_HOST
  SSH Key: $SSH_KEY
  App Port: $APP_PORT
  Repo Folder: $LOCAL_DIR
"

# ------------------------------------------------------------------------------
# Section 2 — Clone or Pull the Repository
# ------------------------------------------------------------------------------
log "=== Cloning or updating repository ==="
if [[ -d "${LOCAL_DIR}/.git" ]]; then
  log "Repository exists, pulling latest changes..."
  (
    cd "$LOCAL_DIR"
    git remote set-url origin "$AUTH_URL"
    git fetch origin
    git checkout "$BRANCH"
    git pull origin "$BRANCH"
  )
else
  git clone --branch "$BRANCH" "$AUTH_URL" "$LOCAL_DIR"
fi

# ------------------------------------------------------------------------------
# Section 3 — Validate Project Structure
# ------------------------------------------------------------------------------
log "=== Validating Docker configuration ==="
cd "$LOCAL_DIR"
if [[ -f Dockerfile ]]; then
  DEPLOY_MODE="dockerfile"
  log "Dockerfile found."
elif [[ -f docker-compose.yml || -f docker-compose.yaml ]]; then
  DEPLOY_MODE="compose"
  log "docker-compose file found."
else
  die "No Dockerfile or docker-compose.yml found in project root."
fi
cd ..

# ------------------------------------------------------------------------------
# Section 4 — Test SSH Connectivity
# ------------------------------------------------------------------------------
log "=== Testing SSH connection to remote server ==="
ssh -i "$SSH_KEY" -o BatchMode=yes -o ConnectTimeout=8 "${REMOTE_USER}@${REMOTE_HOST}" "echo SSH_OK" >/dev/null \
  || die "SSH connection failed. Check IP, username, and key."

# ------------------------------------------------------------------------------
# Section 5 — Prepare Remote Environment
# ------------------------------------------------------------------------------
log "=== Preparing remote server environment ==="
ssh -i "$SSH_KEY" "${REMOTE_USER}@${REMOTE_HOST}" bash -s <<'REMOTE'
set -e
if ! command -v docker >/dev/null; then
  echo "Installing Docker..."
  sudo apt-get update -y
  sudo apt-get install -y ca-certificates curl gnupg lsb-release
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
  echo "deb [arch=\$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] \
  https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
  sudo apt-get update -y && sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
fi

if ! command -v docker-compose >/dev/null && ! docker compose version >/dev/null 2>&1; then
  echo "Installing docker-compose..."
  sudo apt-get install -y docker-compose
fi

if ! command -v nginx >/dev/null; then
  echo "Installing Nginx..."
  sudo apt-get install -y nginx
fi

sudo systemctl enable --now docker nginx
sudo usermod -aG docker "\$USER" || true
docker --version
nginx -v
echo "REMOTE_SETUP_DONE"
REMOTE

# ------------------------------------------------------------------------------
# Cleanup Mode (optional)
# ------------------------------------------------------------------------------
if [[ "$CLEANUP_MODE" == true ]]; then
  log "=== Cleanup Mode Enabled ==="
  ssh -i "$SSH_KEY" "${REMOTE_USER}@${REMOTE_HOST}" bash -s <<REMOTE
sudo docker rm -f ${REPO_NAME} 2>/dev/null || true
sudo docker compose -f /opt/${REPO_NAME}/docker-compose.yml down 2>/dev/null || true
sudo rm -rf /opt/${REPO_NAME} /etc/nginx/sites-available/${REPO_NAME}.conf /etc/nginx/sites-enabled/${REPO_NAME}.conf
sudo systemctl reload nginx
echo "Cleanup completed."
REMOTE
  exit 0
fi

# ------------------------------------------------------------------------------
# Section 6 — Transfer Files & Deploy Containers
# ------------------------------------------------------------------------------
log "=== Transferring project files to remote host ==="
rsync -avz --delete --exclude '.git' --exclude 'node_modules' \
  -e "ssh -i ${SSH_KEY}" "${LOCAL_DIR}/" "${REMOTE_USER}@${REMOTE_HOST}:/opt/${REPO_NAME}/"

log "=== Building and running Docker containers ==="
if [[ "$DEPLOY_MODE" == "compose" ]]; then
  ssh -i "$SSH_KEY" "${REMOTE_USER}@${REMOTE_HOST}" "cd /opt/${REPO_NAME} && sudo docker compose down && sudo docker compose up -d --build"
else
  ssh -i "$SSH_KEY" "${REMOTE_USER}@${REMOTE_HOST}" bash -s <<REMOTE
cd /opt/${REPO_NAME}
sudo docker rm -f ${REPO_NAME} 2>/dev/null || true
sudo docker build -t ${REPO_NAME}:latest .
sudo docker run -d --name ${REPO_NAME} --restart unless-stopped -p 127.0.0.1:${APP_PORT}:${APP_PORT} ${REPO_NAME}:latest
REMOTE
fi

# ------------------------------------------------------------------------------
# Section 7 — Configure Nginx Reverse Proxy
# ------------------------------------------------------------------------------
log "=== Configuring Nginx reverse proxy ==="
ssh -i "$SSH_KEY" "${REMOTE_USER}@${REMOTE_HOST}" sudo tee /etc/nginx/sites-available/${REPO_NAME}.conf > /dev/null <<NGCONF
server {
    listen 80;
    server_name _;
    location / {
        proxy_pass http://127.0.0.1:${APP_PORT};
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    }
}
NGCONF

ssh -i "$SSH_KEY" "${REMOTE_USER}@${REMOTE_HOST}" "sudo ln -sf /etc/nginx/sites-available/${REPO_NAME}.conf /etc/nginx/sites-enabled/${REPO_NAME}.conf && sudo nginx -t && sudo systemctl reload nginx"

# ------------------------------------------------------------------------------
# Section 8 — Validate Deployment
# ------------------------------------------------------------------------------
log "=== Validating deployment ==="
ssh -i "$SSH_KEY" "${REMOTE_USER}@${REMOTE_HOST}" bash -s <<REMOTE
set -e
sudo systemctl is-active --quiet docker || { echo "Docker not running"; exit 1; }
sudo docker ps | grep ${REPO_NAME} || { echo "Container not running"; exit 1; }
curl -I --max-time 5 http://127.0.0.1:${APP_PORT} >/dev/null 2>&1 || { echo "Local port not responding"; exit 1; }
sudo systemctl is-active --quiet nginx || { echo "Nginx not running"; exit 1; }
echo "Deployment validated successfully."
REMOTE

log "=== Testing remote HTTP endpoint ==="
curl -I --max-time 10 "http://${REMOTE_HOST}" || die "Remote endpoint not accessible."

# ------------------------------------------------------------------------------
# Section 9 — Completion
# ------------------------------------------------------------------------------
log "Deployment successful!"
log "Access the app at: http://${REMOTE_HOST}"
log "Full log stored at: ${LOG_FILE}"

exit 0
